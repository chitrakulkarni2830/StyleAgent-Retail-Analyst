"""
=============================================================
agents/wardrobe_architect_agent.py â€” Style Agent Gold Standard
=============================================================
PURPOSE:
  This is Agent 4 â€” the Wardrobe Architect.
  Its job is to build 3 complete outfit options, one per
  colour palette generated by Agent 3.

  For each outfit, it:
    1. Distributes the total budget across all outfit pieces
    2. Queries the current_inventory SQLite table and picks
       items for every required slot (Top/Dress, Bottom,
       Outerwear, Footwear, Bag)
    3. Validates that the total outfit cost stays within budget
    4. Calls LiveLinkScraper to add real shopping links
    5. Writes stylist-quality descriptions and notes

UPGRADES v2:
  - distribute_budget: splits total budget by occasion type
  - validate_outfit_budget: checks total cost and retries if needed
  - LiveLinkScraper integration: adds shopping_link to every item
=============================================================
"""

import sqlite3    # built-in library for database queries
import os         # built-in library for file paths
import random     # built-in library for picking variety

# â”€â”€ Path to the database file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DB_PATH = os.path.join(PROJECT_ROOT, "database", "inventory.db")

# â”€â”€ Import the live link scraper (Upgrade 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# This adds real shopping links to every outfit item
try:
    from scraper.live_link_scraper import LiveLinkScraper  # our new scraper class
    LINKS_AVAILABLE = True   # flag so we know scraping is possible
except ImportError:
    LINKS_AVAILABLE = False  # scraper missing â€” outfits still work, just no links
    print("  âš ï¸  LiveLinkScraper not found â€” shopping links will be skipped")

# â”€â”€ Import colour-family helper (Fix 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# get_search_colours_for_hex: converts a hex code to (family, colour_names)
# used by the 5-tier get_inventory_items query system
try:
    from agents.colour_engine_agent import (
        get_colour_names_for_search,
        get_search_colours_for_hex,   # FIX 1 â€” returns (family, names) tuple
    )
    COLOUR_SEARCH_AVAILABLE = True
except ImportError:
    # If import fails, fall back to no colour matching
    def get_colour_names_for_search(hex_code):
        return []   # empty list = no colour preference used
    def get_search_colours_for_hex(hex_code):
        return "neutral", []   # neutral family = safe fallback
    COLOUR_SEARCH_AVAILABLE = False


# =============================================================
# FIX 7 â€” FORMALITY SCORING
# Maps every supported occasion to a formality score 1-5.
# This is used to pick correctly dressed items from the DB.
# 1 = very casual, 5 = black tie formal
# =============================================================
OCCASION_FORMALITY = {
    # Indian formal (5)
    "wedding":             5,
    "black tie gala":      5,
    "award ceremony":      5,
    "sherwani occasion":   5,
    # Indian semi-formal / party (4)
    "sangeet":             4,
    "formal dinner":       4,
    "reception":           4,
    "theatre":             4,
    "opera":               4,
    "conference":          4,
    "client meeting":      4,
    "job interview":       4,
    "interview":           4,
    "anniversary dinner":  4,
    "date night":          4,
    "first date":          4,
    "girls night out":     4,
    # Mid-level / festive (3)
    "mehendi":             3,
    "diwali":              3,
    "eid":                 3,
    "durga puja":          3,
    "navratri":            3,
    "festival mela":       3,
    "birthday party":      3,
    "house party":         3,
    "farewell":            3,
    "networking event":    3,
    "business lunch":      3,
    "office":              3,
    # Casual (2)
    "haldi":               2,
    "pooja":               2,
    "brunch":              2,
    "movie date":          2,
    "shopping trip":       2,
    "sunday outing":       2,
    "college":             2,
    # Very casual (1)
    "work from home":      1,
    "travel":              1,
    "grocery":             1,
}


# =============================================================
# FIX 5 â€” MATCH TRANSPARENCY MESSAGES
# Shown in the result card when the agent had to loosen its
# search criteria to find a match.
# Tier 1 = perfect â†’ show nothing. Tier 5 = last resort.
# =============================================================
TIER_MESSAGES = {
    1: None,   # perfect match â€” show nothing
    2: "âœ“ Closest match â€” outfit vibe adjusted to fit your occasion",
    3: "âœ“ Colour family matched â€” exact shade unavailable in this vibe",
    4: "âš  No colour match in budget â€” showing best formality fit",
    5: "âš  Limited results â€” showing best available within your budget",
}


# =============================================================
# CLASS: WardrobeArchitectAgent
# =============================================================
class WardrobeArchitectAgent:
    """
    Agent 4: Queries the inventory and builds 3 complete outfits,
    each based on one of the 3 colour palettes from Agent 3.
    Budget is now distributed across pieces by occasion type.
    """

    def __init__(self):
        """Set up the agent â€” no configuration needed at startup."""
        pass

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _get_db_connection
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _get_db_connection(self):
        """
        Opens inventory.db and enables dict-style column access.
        Using dict-style means we can do row["price"] instead of row[3].
        """
        conn = sqlite3.connect(DB_PATH)          # open the database file
        conn.row_factory = sqlite3.Row           # enable column-name access
        return conn                              # return the open connection

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # NEW METHOD: distribute_budget (Upgrade 2)
    # Splits the total budget across outfit pieces by occasion
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def distribute_budget(self, total_budget, occasion, vibe):
        """
        This function splits the total budget across outfit pieces based on occasion.
        Wedding occasions spend more on the outfit, less on accessories.
        Casual occasions spend more evenly across all pieces.

        total_budget: the user's total money available (e.g. 5000)
        occasion:     the occasion keyword e.g. "wedding" or "office"
        vibe:         the selected vibe e.g. "Ethnic" or "Formal"

        Returns: dict mapping piece name â†’ rupee budget for that piece
        """
        # Check which occasion type this is and assign allocation percentages
        if ("wedding" in occasion.lower()
                or "sangeet" in occasion.lower()
                or "mehendi" in occasion.lower()):
            # For Indian wedding occasions: the main outfit is the hero piece,
            # so we give it the biggest share of the budget
            allocation = {
                "top_or_dress": 0.40,   # 40% on the main clothing (kurta/lehenga)
                "bottom":       0.20,   # 20% on bottoms (palazzo, dhoti, etc.)
                "outerwear":    0.10,   # 10% on dupatta / shrug / cape
                "footwear":     0.15,   # 15% on heels / juttis
                "bag":          0.10,   # 10% on clutch / potli
                "jewellery":    0.05,   # 5% on jewellery (small accessories)
            }
        elif ("office" in occasion.lower()
              or "interview" in occasion.lower()
              or "formal" in occasion.lower()
              or "black_tie" in occasion.lower()):
            # For professional occasions: footwear and bag carry the look,
            # so they get a slightly higher slice
            allocation = {
                "top_or_dress": 0.35,   # 35% on top or dress
                "bottom":       0.25,   # 25% on trousers / skirt
                "outerwear":    0.15,   # 15% on blazer / jacket
                "footwear":     0.15,   # 15% on smart shoes
                "bag":          0.08,   # 8% on structured office bag
                "jewellery":    0.02,   # 2% on minimal desk jewellery
            }
        else:
            # Default for casual, social, and date occasions
            # More balance across all pieces
            allocation = {
                "top_or_dress": 0.35,   # 35% on top or dress
                "bottom":       0.25,   # 25% on bottoms
                "outerwear":    0.10,   # 10% on jacket / cardigan
                "footwear":     0.20,   # 20% on shoes (often a statement piece)
                "bag":          0.07,   # 7% on bag
                "jewellery":    0.03,   # 3% on jewellery
            }

        # Calculate the actual rupee limit for each piece
        # round() rounds to the nearest integer so we get clean rupee values
        budget_per_piece = {
            piece: round(total_budget * percentage)   # e.g. 5000 * 0.40 = 2000
            for piece, percentage in allocation.items()
        }

        return budget_per_piece   # returns dict like {"top_or_dress": 2000, "bottom": 1000, ...}

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # NEW METHOD: validate_outfit_budget (Upgrade 2)
    # Checks if an assembled outfit fits within the total budget
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def validate_outfit_budget(self, raw_prices_dict, total_budget):
        """
        Before returning any outfit, this checks that the total cost
        of all pieces combined does not exceed the user's total budget.

        raw_prices_dict: dict of {slot_name: raw_price_float_or_zero}
          e.g. {"dress": 2800, "top": 0, "bottom": 0, "outerwear": 500, ...}
        total_budget: the user's total budget in rupees

        Returns: (is_valid: bool, total_cost: float, remaining: float)
        """
        # Sum up the price of every item in the outfit
        # We use raw float prices here (before formatting with â‚¹ sign)
        total_cost = sum(raw_prices_dict.values())   # add up all piece prices

        # Check if the total is within the user's budget
        if total_cost <= total_budget:
            # Outfit fits the budget â€” calculate how much is left over
            remaining = total_budget - total_cost
            return True, total_cost, remaining   # valid outfit
        else:
            # Outfit is over budget â€” report by how much
            over_by = total_cost - total_budget
            print(f"  âš ï¸  Outfit costs â‚¹{total_cost:,.0f} but budget is â‚¹{total_budget:,.0f}. "
                  f"Over by â‚¹{over_by:,.0f}. Retrying with cheaper items...")
            return False, total_cost, -over_by   # invalid â€” negative remaining = overspent

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # UPGRADE 4 â€” Indian ethnic outfit category selector
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def get_outfit_type_for_occasion_vibe(self, occasion, vibe):
        """
        Returns the correct outfit category list to search in the inventory
        based on the user's selected occasion and vibe.

        This prevents Western dresses appearing when vibe = Ethnic.
        Instead, the correct Indian garment types are returned
        (lehenga, sharara, anarkali, saree, etc.).

        occasion: string e.g. "wedding" or "mehendi"
        vibe:     string e.g. "Ethnic" or "Modern"

        Returns: list of category strings to try in order of preference
        """
        occ = occasion.lower()    # lowercase for easy comparison
        vib = vibe.lower()        # lowercase for easy comparison

        # â”€â”€ ETHNIC vibe: always use Indian garment categories â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if "ethnic" in vib:
            if any(w in occ for w in ["wedding", "sangeet", "reception", "gala"]):
                # Formal ethnic dress codes â€” lehenga is the top choice
                return ["lehenga", "sharara", "saree", "anarkali"]
            elif any(w in occ for w in ["mehendi", "haldi", "navratri", "garba"]):
                # Semi-formal daytime ethnic â€” lighter garments work better
                return ["sharara", "gharara", "anarkali", "lehenga", "Top"]
            elif any(w in occ for w in ["pooja", "diwali", "eid", "festival", "casual"]):
                # Casual ethnic â€” salwar kameez, anarkalis, palazzo works well
                return ["Top", "anarkali", "palazzo_set", "saree", "gharara"]
            else:
                # Default ethnic fallback
                return ["anarkali", "Top", "lehenga", "palazzo_set"]

        # â”€â”€ INDO-WESTERN vibe: fusion categories â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        elif "indo" in vib or "western" == vib:
            if any(w in occ for w in ["wedding", "sangeet", "party", "reception"]):
                return ["dhoti_skirt", "cape_set", "lehenga", "top_or_dress"]
            else:
                return ["palazzo_set", "anarkali", "cape_set", "Top"]

        # â”€â”€ MODERN / WESTERN vibes: standard clothing categories â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        else:
            # Modern, Formal, Casual, Boho, Classic, Streetwear
            return ["Top", "top_or_dress", "bottom"]   # Western garment categories

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _find_item
    # 4-tier fallback query (Fix 1 â€” guarantees results)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _find_item(self, cursor, category, vibe, occasion, budget_max, size,
                   preferred_colour=None, exclude_ids=None):
        """
        Searches current_inventory using 4 progressively relaxed tiers:
          Tier 1: colour + vibe + occasion (strictest)
          Tier 2: vibe + occasion (drop colour)
          Tier 3: occasion only (drop vibe)
          Tier 4: category + price only (always returns something)

        If preferred_colour is a hex code (#RRGGBB), it is first converted
        to a list of colour names using get_colour_names_for_search so we
        can match items by family name even if the exact hex isn't in the DB.

        Returns: dict of item fields, or None if the DB is completely empty.
        """
        if exclude_ids is None:
            exclude_ids = []   # start with no exclusions

        # â”€â”€ Build the exclusion clause once upfront â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if exclude_ids:
            placeholders = ",".join("?" * len(exclude_ids))
            exc = f"AND item_id NOT IN ({placeholders})"  # exclude already-used items
        else:
            exc = ""   # no exclusions

        # â”€â”€ Resolve colour preference â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # If the user passed a hex code like #FF6B35, convert it to a list
        # of searchable names like ["rust","burnt orange","terracotta"].
        # If they passed a plain name like "Terracotta" wrap it in a list.
        # Either way, colour_names is a list of strings to try.
        if preferred_colour:
            if preferred_colour.startswith("#"):
                # hex code â€” use colour-family lookup to get search names
                colour_names = get_colour_names_for_search(preferred_colour)
            else:
                # plain name â€” just use it directly
                colour_names = [preferred_colour.lower()]
        else:
            colour_names = []   # no colour preference

        # â”€â”€ Helper: run one SQL query and return first row â”€â”€â”€â”€
        def run(sql, params):
            """Execute sql with params and return the first row as a dict, or None."""
            cursor.execute(sql, params)
            row = cursor.fetchone()
            return dict(row) if row else None

        # â”€â”€ TIER 1: colour + vibe + occasion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Try every colour name in the list (e.g. rust, terracotta, coral)
        for colour_name in (colour_names or [""]):
            if colour_name:  # only add colour clause if we have a name to search
                tier1_sql = f"""
                    SELECT * FROM current_inventory
                    WHERE category = ?
                      AND lower(vibe) LIKE ?
                      AND lower(occasion_tags) LIKE ?
                      AND price <= ?
                      AND lower(size_available) LIKE ?
                      AND lower(colour) LIKE ?
                      {exc}
                    ORDER BY RANDOM() LIMIT 1
                """
                # params: category, vibe, occasion, price, size, colour, [excluded ids]
                result = run(tier1_sql,
                    [category, f"%{vibe.lower()}%", f"%{occasion.lower()}%",
                     budget_max, f"%{size.lower()}%", f"%{colour_name}%"] + exclude_ids)
                if result:
                    return result   # exact match found

        # â”€â”€ TIER 2: vibe + occasion, no colour â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Drop the colour constraint but keep vibe and occasion
        tier2_sql = f"""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND lower(vibe) LIKE ?
              AND lower(occasion_tags) LIKE ?
              AND price <= ?
              AND lower(size_available) LIKE ?
              {exc}
            ORDER BY RANDOM() LIMIT 1
        """
        result = run(tier2_sql,
            [category, f"%{vibe.lower()}%", f"%{occasion.lower()}%",
             budget_max, f"%{size.lower()}%"] + exclude_ids)
        if result:
            return result

        # â”€â”€ TIER 3: occasion only, drop vibe â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Maybe this vibe has no items, but the occasion does
        tier3_sql = f"""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND lower(occasion_tags) LIKE ?
              AND price <= ?
              AND lower(size_available) LIKE ?
              {exc}
            ORDER BY RANDOM() LIMIT 1
        """
        result = run(tier3_sql,
            [category, f"%{occasion.lower()}%",
             budget_max, f"%{size.lower()}%"] + exclude_ids)
        if result:
            return result

        # â”€â”€ TIER 4: last resort â€” category + price only â”€â”€â”€â”€â”€â”€â”€
        # Guarantees we ALWAYS return something as long as any item exists
        # in this category within the budget. ORDER BY RANDOM() gives variety.
        tier4_sql = f"""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND price <= ?
              {exc}
            ORDER BY RANDOM() LIMIT 1
        """
        result = run(tier4_sql, [category, budget_max] + exclude_ids)
        if result:
            return result

        # â”€â”€ TIER 4b: ignore budget too (very last resort) â”€â”€â”€â”€
        # Only reached if literally no items exist in this category
        tier4b_sql = f"""
            SELECT * FROM current_inventory
            WHERE category = ?
              {exc}
            ORDER BY RANDOM() LIMIT 1
        """
        return run(tier4b_sql, [category] + exclude_ids)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _describe_item
    # Formats one inventory item into a premium description dict
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _describe_item(self, item_dict):
        """
        Converts a raw database row into a rich, stylist-quality dict.
        This is what the GUI displays for each outfit piece.
        """
        if not item_dict:
            return None   # no item found â€” return None so GUI can skip this slot

        # Extract every field we care about from the database row
        name    = item_dict.get("item_name", "Fashion item")   # full descriptive name
        colour  = item_dict.get("colour", "")                  # e.g. "Powder Blue"
        fabric  = item_dict.get("fabric", "")                  # e.g. "Silk-Georgette"
        sil     = item_dict.get("silhouette", "")              # e.g. "A-Line"
        cut     = item_dict.get("cut", "")                     # e.g. "Anarkali"
        fit     = item_dict.get("fit", "")                     # e.g. "Regular"
        price   = item_dict.get("price", 0)                    # numeric price from DB
        brand   = item_dict.get("brand_tier", "Mid-range")     # e.g. "Premium"

        # Return a clean dict the GUI can directly read
        return {
            "name":         name,                    # full item description
            "colour":       colour,                  # colour name
            "fabric":       fabric,                  # fabric type
            "silhouette":   sil,                     # shape / silhouette
            "cut":          cut,                     # cut style
            "fit":          fit,                     # fit type
            "price":        f"â‚¹{price:,.0f}",        # formatted e.g. "â‚¹1,200"
            "brand_tier":   brand,                   # brand quality level
            "item_id":      item_dict.get("item_id", 0),  # database ID
        }

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _write_why_this_works
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _write_why_this_works(self, top, bottom_or_dress, outerwear, palette, occasion, vibe):
        """
        Creates a human-sounding, 3-sentence explanation of why
        this colour combination and outfit works for this occasion.
        """
        # Use whichever is the main piece â€” top if present, otherwise dress
        main_piece  = top if top else bottom_or_dress
        main_colour = main_piece.get("colour", "this hue") if main_piece else "this hue"

        explanation = (
            f"The {palette.get('harmony_type', 'colour')} palette anchors the look in "
            f"{palette.get('primary_colour', main_colour)}, "
            f"with {palette.get('secondary_colour', 'complementary tones')} as the natural counterpart â€” "
            f"a pairing that creates visual interest without sacrificing elegance. "
            f"For a {occasion.replace('_', ' ').title()} occasion, the {vibe} aesthetic balances "
            f"cultural context with individual expression â€” you will feel like yourself, "
            f"only at your most elevated. "
            f"The fabric and silhouette choices ensure comfort across the duration of the event "
            f"without ever compromising on visual impact."
        )
        return explanation

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _write_occasion_notes
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _write_occasion_notes(self, occasion, vibe):
        """
        Returns 2 actionable, occasion-specific styling tips as a list.
        """
        notes_library = {
            "wedding": [
                "Pin your dupatta to your shoulder for maximum movement during dance sequences.",
                "Carry a small potli bag â€” a large tote reads too casual at a wedding.",
            ],
            "sangeet": [
                "Opt for footwear with a block heel or kitten heel â€” you will be dancing for hours.",
                "Layer jewellery from lightweight to statement for progression through the evening.",
            ],
            "office": [
                "Tuck your blouse in precisely â€” a clean tuck signals intentionality and confidence.",
                "Keep accessories monochromatic so attention stays on your work, not the style clash.",
            ],
            "date_night": [
                "Let one element be the statement â€” either the outfit OR the jewellery, never both.",
                "Spritz fragrance at the wrist pulse points and the back of the neck.",
            ],
            "festival": [
                "Choose breathable fabrics â€” cotton, chanderi, or georgette â€” for outdoor settings.",
                "Secure all jewellery properly before exploring crowded fair grounds.",
            ],
            "mehendi": [
                "Avoid fitted sleeves â€” you will need easy access for your hands during the application.",
                "Choose green-yellow tones to complement henna beautifully in photographs.",
            ],
        }
        # Return notes for the specific occasion, or generic notes if not in library
        return notes_library.get(
            occasion.lower(),
            [
                f"Dress one level above what you think is required â€” you will never regret it.",
                "Carry safety pins, body tape, and a small fragrance â€” a prepared outfit is a confident outfit.",
            ]
        )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # METHOD: _build_one_outfit (UPGRADED with budget distribution)
    # Builds a single complete outfit from inventory
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _build_one_outfit(self, cursor, palette, persona, occasion, vibe,
                          total_budget, size, outfit_number):
        """
        Queries inventory to fill all outfit slots for one palette.
        Uses distribute_budget to allocate spending per piece.
        Returns a complete outfit dictionary.

        total_budget: the full budget for the entire outfit (Upgrade 2)
        """
        chosen_ids = []   # track chosen item IDs to avoid duplicate pieces

        # Extract colour names from the palette for database colour matching
        primary_col   = palette.get("primary_colour", "")    # e.g. "Terracotta"
        secondary_col = palette.get("secondary_colour", "")  # e.g. "Cobalt Blue"

        # â”€â”€ UPGRADE 2: Distribute the total budget across pieces â”€â”€
        # Instead of giving every piece the same max budget, we split
        # the total proportionally based on occasion importance
        budgets = self.distribute_budget(total_budget, occasion, vibe)
        top_budget      = budgets["top_or_dress"]   # e.g. â‚¹2000 of a â‚¹5000 total
        bottom_budget   = budgets["bottom"]          # e.g. â‚¹1000
        outerwear_budget = budgets["outerwear"]      # e.g. â‚¹500
        footwear_budget = budgets["footwear"]        # e.g. â‚¹750
        bag_budget      = budgets["bag"]             # e.g. â‚¹500

        # â”€â”€ Slot 1: Try Dress first, then Top â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # full-body Dress uses the top_or_dress budget allocation
        dress = self._find_item(cursor, "Dress", vibe, occasion,
                                top_budget, size, primary_col, chosen_ids)
        if dress:
            chosen_ids.append(dress["item_id"])   # mark as taken
            top    = None   # if we have a dress, skip the top
            bottom = None   # if we have a dress, skip the bottom
        else:
            # No dress found at this budget â€” try a separate top
            top = self._find_item(cursor, "Top", vibe, occasion,
                                  top_budget, size, primary_col, chosen_ids)
            if top:
                chosen_ids.append(top["item_id"])

            # Find a bottom to pair with the top, using secondary colour
            bottom = self._find_item(cursor, "Bottom", vibe, occasion,
                                     bottom_budget, size, secondary_col, chosen_ids)
            if bottom:
                chosen_ids.append(bottom["item_id"])

        # â”€â”€ Slot 2: Outerwear (dupatta / blazer / shrug) â”€â”€â”€â”€â”€â”€â”€â”€â”€
        outerwear = self._find_item(cursor, "Outerwear", vibe, occasion,
                                    outerwear_budget, size, None, chosen_ids)
        if outerwear:
            chosen_ids.append(outerwear["item_id"])

        # â”€â”€ Slot 3: Footwear â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Footwear uses "All Sizes" because shoes use numeric sizes, not XS/M/L
        footwear = self._find_item(cursor, "Footwear", vibe, occasion,
                                   footwear_budget, "All Sizes", None, chosen_ids)
        if footwear:
            chosen_ids.append(footwear["item_id"])

        # â”€â”€ Slot 4: Bag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Bags use "One Size" since they have no size variations
        bag = self._find_item(cursor, "Bag", vibe, occasion,
                              bag_budget, "One Size", None, chosen_ids)
        if bag:
            chosen_ids.append(bag["item_id"])

        # â”€â”€ Track raw prices for budget validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # We store raw float prices from the DB rows (before formatting)
        raw_prices = {
            "dress":     (dress     or {}).get("price", 0),   # 0 if slot is empty
            "top":       (top       or {}).get("price", 0),
            "bottom":    (bottom    or {}).get("price", 0),
            "outerwear": (outerwear or {}).get("price", 0),
            "footwear":  (footwear  or {}).get("price", 0),
            "bag":       (bag       or {}).get("price", 0),
        }

        # â”€â”€ Validate that total cost fits within total budget â”€â”€â”€â”€â”€
        is_valid, total_cost, remaining = self.validate_outfit_budget(raw_prices, total_budget)
        # Note: we always proceed even if slightly over budget;
        # the validate method prints a warning and the GUI shows the overage

        # â”€â”€ Write stylist narrative â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        why_this_works = self._write_why_this_works(
            top or dress, bottom, outerwear, palette, occasion, vibe
        )
        occasion_notes = self._write_occasion_notes(occasion, vibe)

        # â”€â”€ Assemble the complete outfit dict â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        outfit = {
            "outfit_number":   outfit_number,
            # Palette name e.g. "Option A â€” Analogous Palette"
            "palette_name":    f"Option {['A', 'B', 'C'][outfit_number - 1]} â€” "
                               f"{palette.get('harmony_type', 'Curated')} Palette",
            # Three colour swatches for the UI to display as coloured circles
            "colour_swatches": [
                {"name": palette.get("primary_colour",   "Primary"),
                 "hex":  palette.get("primary_hex",   "#000")},
                {"name": palette.get("secondary_colour", "Secondary"),
                 "hex":  palette.get("secondary_hex", "#888")},
                {"name": palette.get("accent_colour",    "Accent"),
                 "hex":  palette.get("accent_hex",    "#FFF")},
            ],
            # All clothing items with their formatted details
            "items": {
                "dress":     self._describe_item(dress)      if dress     else None,
                "top":       self._describe_item(top)        if top       else None,
                "bottom":    self._describe_item(bottom)     if bottom    else None,
                "outerwear": self._describe_item(outerwear)  if outerwear else None,
                "footwear":  self._describe_item(footwear)   if footwear  else None,
                "bag":       self._describe_item(bag)        if bag       else None,
            },
            # Budget information (Upgrade 2 additions)
            "total_cost":           total_cost,            # raw float, e.g. 2840.0
            "total_estimated_cost": f"â‚¹{total_cost:,.0f}", # formatted, e.g. "â‚¹2,840"
            "budget_given":         total_budget,          # the user's stated budget
            "budget_remaining":     max(0, remaining),     # money left over (0 if over)
            "within_budget":        is_valid,              # True if fits, False if over
            # Stylist narrative
            "why_this_works":       why_this_works,
            "occasion_notes":       occasion_notes,
            "colour_rationale":     palette.get("colour_rationale", ""),
        }

        return outfit   # return the complete outfit dict

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # METHOD: run â€” THE MAIN ENTRY POINT (UPGRADED)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def run(self, palettes, persona, occasion, vibe, total_budget=None):
        """
        Builds 3 complete outfits â€” one per colour palette.
        Now uses total_budget for full-outfit budget distribution (Upgrade 2).
        After each outfit, calls LiveLinkScraper to add shopping links (Upgrade 1).

        palettes:     list of 3 palette dicts from ColourEngineAgent
        persona:      dict from PersonaAgent with size, etc.
        occasion:     e.g. 'wedding', 'office', 'date_night'
        vibe:         e.g. 'Ethnic', 'Modern', 'Boho'
        total_budget: the user's TOTAL budget for the complete outfit (Upgrade 2)
                      Falls back to persona budget_max if not provided.

        Returns: list of 3 outfit dicts (each enriched with shopping links)
        """
        print(f"  ğŸ‘— Wardrobe Architect: Building 3 looks for {occasion} ({vibe} vibe)...")

        # Resolve total budget: prefer the directly passed value,
        # fall back to persona's budget_max for backwards compatibility
        if total_budget is None:
            total_budget = persona.get("budget_max", 15000)   # fallback to persona budget

        # Get the user's clothing size from persona profile
        size = persona.get("size", "M")   # default to Medium if not set

        print(f"  ğŸ’° Total outfit budget: â‚¹{total_budget:,.0f} | Size: {size}")

        # Open the database connection for all queries
        conn   = self._get_db_connection()
        cursor = conn.cursor()

        outfits = []   # list to collect all 3 completed outfits

        # â”€â”€ Create live link scraper instance (Upgrade 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # We create ONE scraper and reuse it for all outfits
        scraper = LiveLinkScraper() if LINKS_AVAILABLE else None

        # â”€â”€ Loop through each colour palette and build one outfit â”€â”€
        for outfit_number, palette in enumerate(palettes, start=1):
            print(f"\n  Building Outfit {outfit_number} ({palette.get('harmony_type', '')})...")

            outfit = self._build_one_outfit(
                cursor    = cursor,
                palette   = palette,
                persona   = persona,
                occasion  = occasion,
                vibe      = vibe,
                total_budget = total_budget,   # pass the full budget (Upgrade 2)
                size      = size,
                outfit_number = outfit_number
            )

            # â”€â”€ Add shopping links to every item (Upgrade 1) â”€â”€â”€â”€â”€â”€â”€
            if scraper is not None:
                print(f"  ğŸ›  Finding shopping links for Outfit {outfit_number}...")
                try:
                    outfit = scraper.get_outfit_links(outfit)   # enrich with real URLs
                except Exception as link_error:
                    # Never let link scraping crash the outfit generation
                    print(f"  âš ï¸  Link scraping failed for outfit {outfit_number}: {link_error}")

            outfits.append(outfit)  # add completed outfit to our list
            print(f"  âœ…  Outfit {outfit_number} ready "
                  f"(â‚¹{outfit['total_cost']:,.0f} of â‚¹{total_budget:,.0f})")

        conn.close()   # close the database connection when all outfits are built
        print(f"  âœ… All 3 outfits ready!")
        return outfits   # return the list of 3 enriched outfit dicts

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # FIX 1 â€” 5-TIER INVENTORY QUERY (colour_family matching)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def get_inventory_items(self, conn, category, user_hex, vibe, occasion,
                            max_price, gender="Women", target_formality=3):
        """
        Finds matching inventory items using a 5-tier fallback system.
        Each tier is slightly looser than the last.
        This guarantees the user ALWAYS gets outfit results.

        Tier 1: colour_family + vibe + occasion + gender + formality Â±1  (strictest)
        Tier 2: colour_family + vibe + gender           (drop occasion)
        Tier 3: colour_family + gender                  (drop vibe)
        Tier 4: gender + formality + price              (drop colour)
        Tier 5: gender + price only                     (last resort)

        Returns: (list_of_row_dicts, matched_tier_int, colour_family_str)
        """
        cursor = conn.cursor()

        # Convert the user's hex code to a colour family name and colour list
        colour_family, colour_names = get_search_colours_for_hex(user_hex)

        matched_tier = 5   # default to last resort; updated as tiers succeed

        vibe_lower     = vibe.lower()        # e.g. "ethnic"
        occasion_lower = occasion.lower()    # e.g. "wedding"

        # â”€â”€ Tier 1: strictest â€” all 5 criteria â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        cursor.execute("""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND colour_family = ?
              AND LOWER(vibe_tags) LIKE ?
              AND LOWER(occasion_tags) LIKE ?
              AND (gender = ? OR gender = 'Unisex')
              AND formality_score BETWEEN ? AND ?
              AND price <= ?
              AND stock_count > 0
            ORDER BY price DESC
            LIMIT 8
        """, (category, colour_family,
              f"%{vibe_lower}%",
              f"%{occasion_lower.split('/')[0].strip()}%",
              gender,
              max(1, target_formality - 1),   # allow 1 step below target
              min(5, target_formality + 1),   # allow 1 step above target
              max_price))
        results = cursor.fetchall()
        if results:
            return results, 1, colour_family

        # â”€â”€ Tier 2: drop occasion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        cursor.execute("""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND colour_family = ?
              AND LOWER(vibe_tags) LIKE ?
              AND (gender = ? OR gender = 'Unisex')
              AND price <= ?
              AND stock_count > 0
            ORDER BY formality_score DESC
            LIMIT 8
        """, (category, colour_family, f"%{vibe_lower}%", gender, max_price))
        results = cursor.fetchall()
        if results:
            return results, 2, colour_family

        # â”€â”€ Tier 3: drop vibe, keep colour family + gender â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        cursor.execute("""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND colour_family = ?
              AND (gender = ? OR gender = 'Unisex')
              AND price <= ?
              AND stock_count > 0
            ORDER BY formality_score DESC
            LIMIT 8
        """, (category, colour_family, gender, max_price))
        results = cursor.fetchall()
        if results:
            return results, 3, colour_family

        # â”€â”€ Tier 4: drop colour, keep gender + formality â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        cursor.execute("""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND (gender = ? OR gender = 'Unisex')
              AND formality_score BETWEEN ? AND ?
              AND price <= ?
              AND stock_count > 0
            ORDER BY RANDOM()
            LIMIT 8
        """, (category, gender,
              max(1, target_formality - 1),
              min(5, target_formality + 1),
              max_price))
        results = cursor.fetchall()
        if results:
            return results, 4, colour_family

        # â”€â”€ Tier 5: absolute last resort â€” just gender + price â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        cursor.execute("""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND (gender = ? OR gender = 'Unisex')
              AND price <= ?
              AND stock_count > 0
            ORDER BY RANDOM()
            LIMIT 8
        """, (category, gender, max_price))
        results = cursor.fetchall()
        return results, 5, colour_family   # always return even if empty

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # FIX 7 â€” FORMALITY SCORING
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @staticmethod
    def get_formality_for_occasion(occasion_text):
        """
        Returns the formality score (1-5) for a given occasion string.
        Uses partial keyword matching so "Wedding Guest" matches "wedding".

        occasion_text: any occasion string the user typed
        Returns: int 1-5 (default 3 if no keyword matched)
        """
        occasion_lower = occasion_text.lower()   # lowercase for comparison

        # Check each known keyword against the user's occasion text
        for keyword, score in OCCASION_FORMALITY.items():
            if keyword in occasion_lower:
                return score   # return as soon as we find a match

        return 3   # default: mid-level if no keyword matched

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # FIX 3 â€” GENDER-AWARE CATEGORY ROUTING
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def get_outfit_categories_for_gender_vibe_occasion(self, gender, vibe, occasion):
        """
        Returns the ordered list of DB categories to search for,
        based on gender + vibe + occasion.

        Women Ethnic + Wedding â†’ [lehenga, saree, sharara, anarkali]
        Men Ethnic + Wedding   â†’ [sherwani, bandhgala, kurta_pyjama, nehru_jacket]
        Women Modern           â†’ [top_or_dress, top, bottom]
        Men Modern             â†’ [top, bottom, outerwear]

        gender:  "Women" or "Men"
        vibe:    e.g. "Ethnic" or "Modern"
        occasion: e.g. "Wedding Guest" or "Office"
        Returns: list of category strings (ordered, first = most preferred)
        """
        g   = gender.lower()    # "women" or "men"
        v   = vibe.lower()      # "ethnic", "modern" etc.
        occ = occasion.lower()  # "wedding", "office" etc.

        # â”€â”€ WOMEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if g == "women":
            if v == "ethnic":
                if any(w in occ for w in ["wedding", "sangeet", "reception", "gala"]):
                    return ["lehenga", "saree", "sharara", "anarkali"]
                elif any(w in occ for w in ["mehendi", "haldi", "navratri", "eid"]):
                    return ["sharara", "gharara", "anarkali", "lehenga", "salwar_suit"]
                else:
                    return ["salwar_suit", "anarkali", "saree", "lehenga"]
            elif "indo" in v:
                return ["dhoti_skirt", "cape_set", "anarkali", "salwar_suit"]
            else:
                return ["top_or_dress", "top", "bottom"]   # modern / casual / boho etc.

        # â”€â”€ MEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        elif g == "men":
            if v == "ethnic":
                if any(w in occ for w in ["wedding", "sangeet", "reception", "gala"]):
                    return ["sherwani", "bandhgala", "kurta_pyjama", "nehru_jacket"]
                elif any(w in occ for w in ["pooja", "diwali", "eid", "casual"]):
                    return ["kurta_pyjama", "nehru_jacket"]
                else:
                    return ["kurta_pyjama", "sherwani", "bandhgala"]
            elif "indo" in v:
                return ["nehru_jacket", "bandhgala", "kurta_pyjama"]
            else:
                return ["top", "bottom", "outerwear"]   # shirt + trouser + blazer

        # â”€â”€ FALLBACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        return ["top", "bottom", "outerwear"]   # safe default

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # FIX 5 â€” MATCH TRANSPARENCY MESSAGE BUILDER
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @staticmethod
    def build_match_message(tier, user_hex, colour_family, vibe, occasion):
        """
        Builds a human-readable message explaining how the outfit was matched.
        Shown in the result card so the user understands any substitutions.

        tier:          int 1-5 from get_inventory_items()
        user_hex:      the hex the user picked e.g. "#8B0000"
        colour_family: e.g. "jewel"
        vibe:          e.g. "Ethnic"
        occasion:      e.g. "Wedding Guest"
        Returns: string message, or None if perfect match (tier 1)
        """
        base_message = TIER_MESSAGES.get(tier)   # look up the message for this tier

        if base_message is None:
            return None   # tier 1 = perfect match, show nothing

        # For tiers 3 and 4, add colour context to explain the substitution
        if tier in [3, 4]:
            detail = (
                f" Your chosen colour ({user_hex}) is in the "
                f"'{colour_family}' family â€” showing best '{colour_family}' "
                f"alternatives available."
            )
            return base_message + detail

        return base_message   # tiers 2 and 5 use the message as-is


# =============================================================
# FIX 4 â€” OUTFIT COHERENCE VALIDATOR
# Standalone class â€” call validator.validate(outfit, formality)
# after WardrobeArchitectAgent builds an outfit.
# =============================================================
class OutfitCoherenceValidator:
    """
    Checks whether the pieces in a recommended outfit make sense together.
    Prevents mismatches like: heavy bridal lehenga + casual flat sneakers.

    Checks:
    1. Footwear formality (block heels for weddings, sneakers for casual)
    2. Bag type formality (clutch for formal, tote for casual)
    3. Dupatta presence for ethnic outfits
    """

    # What footwear silhouettes are appropriate at each formality level
    FOOTWEAR_FORMALITY_RULES = {
        5: ["block heel sandal", "stiletto", "kitten heel", "oxford formal",
            "mojari", "kolhapuri flat"],             # formal: heels or dressy flats
        4: ["block heel sandal", "kitten heel", "oxford formal", "penny loafer",
            "mule heel", "heeled sandal", "mojari"],
        3: ["kitten heel", "mule heel", "flat sandal", "penny loafer",
            "block heel sandal", "kolhapuri flat", "loafer"],
        2: ["flat sandal", "kolhapuri flat", "penny loafer", "low sneaker",
            "mule heel", "flat boot"],
        1: ["low sneaker", "flat sandal", "kolhapuri flat",
            "chunky sneaker", "flatform sneaker"],
    }

    # What bag silhouettes are appropriate at each formality level
    BAG_FORMALITY_RULES = {
        5: ["potli", "clutch", "envelope clutch"],
        4: ["clutch", "potli", "crossbody"],
        3: ["crossbody", "tote", "clutch", "potli", "jhola bag"],
        2: ["tote", "crossbody", "woven tote", "jhola bag"],
        1: ["tote", "crossbody", "jhola bag"],
    }

    # Categories that are Indian ethnic and should always have a dupatta
    ETHNIC_CATEGORIES_NEEDING_DUPATTA = {
        "lehenga", "sharara", "gharara", "salwar_suit"
    }

    def validate(self, outfit_dict, target_formality):
        """
        Checks an outfit dict for coherence issues.
        Returns: (is_valid_bool, list_of_issue_strings, outfit_dict)

        The outfit_dict is returned unchanged â€” this validator only reports,
        it does not modify the outfit (the agent can re-query if needed).
        """
        issues = []   # collect any problems found

        # â”€â”€ Check 1: footwear formality â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        footwear = outfit_dict.get("footwear")
        if footwear and isinstance(footwear, dict):
            allowed_shoes = self.FOOTWEAR_FORMALITY_RULES.get(target_formality, [])
            shoe_silhouette = footwear.get("silhouette", "").lower()

            # Check if ANY allowed type appears in this shoe's silhouette string
            shoe_ok = any(allowed in shoe_silhouette for allowed in allowed_shoes)

            if not shoe_ok and shoe_silhouette:
                issues.append(
                    f"Footwear: '{footwear.get('item_name', '')}' "
                    f"(silhouette: {shoe_silhouette}) may be too casual for "
                    f"formality level {target_formality}. "
                    f"Consider: {', '.join(allowed_shoes[:3])}"
                )

        # â”€â”€ Check 2: bag formality â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        bag = outfit_dict.get("bag")
        if bag and isinstance(bag, dict):
            allowed_bags = self.BAG_FORMALITY_RULES.get(target_formality, [])
            bag_silhouette = bag.get("silhouette", "").lower()
            bag_ok = any(allowed in bag_silhouette for allowed in allowed_bags)

            if not bag_ok and bag_silhouette:
                issues.append(
                    f"Bag: '{bag.get('item_name', '')}' may not suit "
                    f"formality level {target_formality}. "
                    f"Consider: {', '.join(allowed_bags[:2])}"
                )

        # â”€â”€ Check 3: dupatta for ethnic outfits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        main_cat    = outfit_dict.get("main_item_category", "")
        outerwear   = outfit_dict.get("outerwear")

        if main_cat in self.ETHNIC_CATEGORIES_NEEDING_DUPATTA:
            # Outerwear slot should contain a dupatta for these categories
            has_dupatta = (
                outerwear and isinstance(outerwear, dict) and
                "dupatta" in outerwear.get("silhouette", "").lower()
            )
            if not has_dupatta:
                issues.append(
                    "Dupatta missing: ethnic outfit (lehenga/sharara/salwar) "
                    "should include a dupatta. Consider adding a plain organza one."
                )

        is_valid = len(issues) == 0   # valid if no issues found
        return is_valid, issues, outfit_dict
