"""
=============================================================
agents/wardrobe_architect_agent.py â€” Style Agent Gold Standard
=============================================================
PURPOSE:
  This is Agent 4 â€” the Wardrobe Architect.
  Its job is to build 3 complete outfit options, one per
  colour palette generated by Agent 3.

  For each outfit, it:
    1. Distributes the total budget across all outfit pieces
    2. Queries the current_inventory SQLite table and picks
       items for every required slot (Top/Dress, Bottom,
       Outerwear, Footwear, Bag)
    3. Validates that the total outfit cost stays within budget
    4. Calls LiveLinkScraper to add real shopping links
    5. Writes stylist-quality descriptions and notes

UPGRADES v2:
  - distribute_budget: splits total budget by occasion type
  - validate_outfit_budget: checks total cost and retries if needed
  - LiveLinkScraper integration: adds shopping_link to every item
=============================================================
"""

import sqlite3    # built-in library for database queries
import os         # built-in library for file paths
import random     # built-in library for picking variety

# â”€â”€ Path to the database file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DB_PATH = os.path.join(PROJECT_ROOT, "database", "inventory.db")

# â”€â”€ Import the live link scraper (Upgrade 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# This adds real shopping links to every outfit item
try:
    from scraper.live_link_scraper import LiveLinkScraper  # our new scraper class
    LINKS_AVAILABLE = True   # flag so we know scraping is possible
except ImportError:
    LINKS_AVAILABLE = False  # scraper missing â€” outfits still work, just no links
    print("  âš ï¸  LiveLinkScraper not found â€” shopping links will be skipped")

# â”€â”€ Import colour-family helper (Fix 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Converts any hex code like #FF6B35 into a list of colour names
# we can search for in the database (e.g. ["rust","terracotta","coral"])
try:
    from agents.colour_engine_agent import get_colour_names_for_search
    COLOUR_SEARCH_AVAILABLE = True
except ImportError:
    # If import fails, fall back to no colour matching
    def get_colour_names_for_search(hex_code):
        return []   # empty list = no colour preference used
    COLOUR_SEARCH_AVAILABLE = False


# =============================================================
# CLASS: WardrobeArchitectAgent
# =============================================================
class WardrobeArchitectAgent:
    """
    Agent 4: Queries the inventory and builds 3 complete outfits,
    each based on one of the 3 colour palettes from Agent 3.
    Budget is now distributed across pieces by occasion type.
    """

    def __init__(self):
        """Set up the agent â€” no configuration needed at startup."""
        pass

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _get_db_connection
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _get_db_connection(self):
        """
        Opens inventory.db and enables dict-style column access.
        Using dict-style means we can do row["price"] instead of row[3].
        """
        conn = sqlite3.connect(DB_PATH)          # open the database file
        conn.row_factory = sqlite3.Row           # enable column-name access
        return conn                              # return the open connection

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # NEW METHOD: distribute_budget (Upgrade 2)
    # Splits the total budget across outfit pieces by occasion
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def distribute_budget(self, total_budget, occasion, vibe):
        """
        This function splits the total budget across outfit pieces based on occasion.
        Wedding occasions spend more on the outfit, less on accessories.
        Casual occasions spend more evenly across all pieces.

        total_budget: the user's total money available (e.g. 5000)
        occasion:     the occasion keyword e.g. "wedding" or "office"
        vibe:         the selected vibe e.g. "Ethnic" or "Formal"

        Returns: dict mapping piece name â†’ rupee budget for that piece
        """
        # Check which occasion type this is and assign allocation percentages
        if ("wedding" in occasion.lower()
                or "sangeet" in occasion.lower()
                or "mehendi" in occasion.lower()):
            # For Indian wedding occasions: the main outfit is the hero piece,
            # so we give it the biggest share of the budget
            allocation = {
                "top_or_dress": 0.40,   # 40% on the main clothing (kurta/lehenga)
                "bottom":       0.20,   # 20% on bottoms (palazzo, dhoti, etc.)
                "outerwear":    0.10,   # 10% on dupatta / shrug / cape
                "footwear":     0.15,   # 15% on heels / juttis
                "bag":          0.10,   # 10% on clutch / potli
                "jewellery":    0.05,   # 5% on jewellery (small accessories)
            }
        elif ("office" in occasion.lower()
              or "interview" in occasion.lower()
              or "formal" in occasion.lower()
              or "black_tie" in occasion.lower()):
            # For professional occasions: footwear and bag carry the look,
            # so they get a slightly higher slice
            allocation = {
                "top_or_dress": 0.35,   # 35% on top or dress
                "bottom":       0.25,   # 25% on trousers / skirt
                "outerwear":    0.15,   # 15% on blazer / jacket
                "footwear":     0.15,   # 15% on smart shoes
                "bag":          0.08,   # 8% on structured office bag
                "jewellery":    0.02,   # 2% on minimal desk jewellery
            }
        else:
            # Default for casual, social, and date occasions
            # More balance across all pieces
            allocation = {
                "top_or_dress": 0.35,   # 35% on top or dress
                "bottom":       0.25,   # 25% on bottoms
                "outerwear":    0.10,   # 10% on jacket / cardigan
                "footwear":     0.20,   # 20% on shoes (often a statement piece)
                "bag":          0.07,   # 7% on bag
                "jewellery":    0.03,   # 3% on jewellery
            }

        # Calculate the actual rupee limit for each piece
        # round() rounds to the nearest integer so we get clean rupee values
        budget_per_piece = {
            piece: round(total_budget * percentage)   # e.g. 5000 * 0.40 = 2000
            for piece, percentage in allocation.items()
        }

        return budget_per_piece   # returns dict like {"top_or_dress": 2000, "bottom": 1000, ...}

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # NEW METHOD: validate_outfit_budget (Upgrade 2)
    # Checks if an assembled outfit fits within the total budget
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def validate_outfit_budget(self, raw_prices_dict, total_budget):
        """
        Before returning any outfit, this checks that the total cost
        of all pieces combined does not exceed the user's total budget.

        raw_prices_dict: dict of {slot_name: raw_price_float_or_zero}
          e.g. {"dress": 2800, "top": 0, "bottom": 0, "outerwear": 500, ...}
        total_budget: the user's total budget in rupees

        Returns: (is_valid: bool, total_cost: float, remaining: float)
        """
        # Sum up the price of every item in the outfit
        # We use raw float prices here (before formatting with â‚¹ sign)
        total_cost = sum(raw_prices_dict.values())   # add up all piece prices

        # Check if the total is within the user's budget
        if total_cost <= total_budget:
            # Outfit fits the budget â€” calculate how much is left over
            remaining = total_budget - total_cost
            return True, total_cost, remaining   # valid outfit
        else:
            # Outfit is over budget â€” report by how much
            over_by = total_cost - total_budget
            print(f"  âš ï¸  Outfit costs â‚¹{total_cost:,.0f} but budget is â‚¹{total_budget:,.0f}. "
                  f"Over by â‚¹{over_by:,.0f}. Retrying with cheaper items...")
            return False, total_cost, -over_by   # invalid â€” negative remaining = overspent

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # UPGRADE 4 â€” Indian ethnic outfit category selector
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def get_outfit_type_for_occasion_vibe(self, occasion, vibe):
        """
        Returns the correct outfit category list to search in the inventory
        based on the user's selected occasion and vibe.

        This prevents Western dresses appearing when vibe = Ethnic.
        Instead, the correct Indian garment types are returned
        (lehenga, sharara, anarkali, saree, etc.).

        occasion: string e.g. "wedding" or "mehendi"
        vibe:     string e.g. "Ethnic" or "Modern"

        Returns: list of category strings to try in order of preference
        """
        occ = occasion.lower()    # lowercase for easy comparison
        vib = vibe.lower()        # lowercase for easy comparison

        # â”€â”€ ETHNIC vibe: always use Indian garment categories â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if "ethnic" in vib:
            if any(w in occ for w in ["wedding", "sangeet", "reception", "gala"]):
                # Formal ethnic dress codes â€” lehenga is the top choice
                return ["lehenga", "sharara", "saree", "anarkali"]
            elif any(w in occ for w in ["mehendi", "haldi", "navratri", "garba"]):
                # Semi-formal daytime ethnic â€” lighter garments work better
                return ["sharara", "gharara", "anarkali", "lehenga", "Top"]
            elif any(w in occ for w in ["pooja", "diwali", "eid", "festival", "casual"]):
                # Casual ethnic â€” salwar kameez, anarkalis, palazzo works well
                return ["Top", "anarkali", "palazzo_set", "saree", "gharara"]
            else:
                # Default ethnic fallback
                return ["anarkali", "Top", "lehenga", "palazzo_set"]

        # â”€â”€ INDO-WESTERN vibe: fusion categories â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        elif "indo" in vib or "western" == vib:
            if any(w in occ for w in ["wedding", "sangeet", "party", "reception"]):
                return ["dhoti_skirt", "cape_set", "lehenga", "top_or_dress"]
            else:
                return ["palazzo_set", "anarkali", "cape_set", "Top"]

        # â”€â”€ MODERN / WESTERN vibes: standard clothing categories â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        else:
            # Modern, Formal, Casual, Boho, Classic, Streetwear
            return ["Top", "top_or_dress", "bottom"]   # Western garment categories

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _find_item
    # 4-tier fallback query (Fix 1 â€” guarantees results)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _find_item(self, cursor, category, vibe, occasion, budget_max, size,
                   preferred_colour=None, exclude_ids=None):
        """
        Searches current_inventory using 4 progressively relaxed tiers:
          Tier 1: colour + vibe + occasion (strictest)
          Tier 2: vibe + occasion (drop colour)
          Tier 3: occasion only (drop vibe)
          Tier 4: category + price only (always returns something)

        If preferred_colour is a hex code (#RRGGBB), it is first converted
        to a list of colour names using get_colour_names_for_search so we
        can match items by family name even if the exact hex isn't in the DB.

        Returns: dict of item fields, or None if the DB is completely empty.
        """
        if exclude_ids is None:
            exclude_ids = []   # start with no exclusions

        # â”€â”€ Build the exclusion clause once upfront â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if exclude_ids:
            placeholders = ",".join("?" * len(exclude_ids))
            exc = f"AND item_id NOT IN ({placeholders})"  # exclude already-used items
        else:
            exc = ""   # no exclusions

        # â”€â”€ Resolve colour preference â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # If the user passed a hex code like #FF6B35, convert it to a list
        # of searchable names like ["rust","burnt orange","terracotta"].
        # If they passed a plain name like "Terracotta" wrap it in a list.
        # Either way, colour_names is a list of strings to try.
        if preferred_colour:
            if preferred_colour.startswith("#"):
                # hex code â€” use colour-family lookup to get search names
                colour_names = get_colour_names_for_search(preferred_colour)
            else:
                # plain name â€” just use it directly
                colour_names = [preferred_colour.lower()]
        else:
            colour_names = []   # no colour preference

        # â”€â”€ Helper: run one SQL query and return first row â”€â”€â”€â”€
        def run(sql, params):
            """Execute sql with params and return the first row as a dict, or None."""
            cursor.execute(sql, params)
            row = cursor.fetchone()
            return dict(row) if row else None

        # â”€â”€ TIER 1: colour + vibe + occasion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Try every colour name in the list (e.g. rust, terracotta, coral)
        for colour_name in (colour_names or [""]):
            if colour_name:  # only add colour clause if we have a name to search
                tier1_sql = f"""
                    SELECT * FROM current_inventory
                    WHERE category = ?
                      AND lower(vibe) LIKE ?
                      AND lower(occasion_tags) LIKE ?
                      AND price <= ?
                      AND lower(size_available) LIKE ?
                      AND lower(colour) LIKE ?
                      {exc}
                    ORDER BY RANDOM() LIMIT 1
                """
                # params: category, vibe, occasion, price, size, colour, [excluded ids]
                result = run(tier1_sql,
                    [category, f"%{vibe.lower()}%", f"%{occasion.lower()}%",
                     budget_max, f"%{size.lower()}%", f"%{colour_name}%"] + exclude_ids)
                if result:
                    return result   # exact match found

        # â”€â”€ TIER 2: vibe + occasion, no colour â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Drop the colour constraint but keep vibe and occasion
        tier2_sql = f"""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND lower(vibe) LIKE ?
              AND lower(occasion_tags) LIKE ?
              AND price <= ?
              AND lower(size_available) LIKE ?
              {exc}
            ORDER BY RANDOM() LIMIT 1
        """
        result = run(tier2_sql,
            [category, f"%{vibe.lower()}%", f"%{occasion.lower()}%",
             budget_max, f"%{size.lower()}%"] + exclude_ids)
        if result:
            return result

        # â”€â”€ TIER 3: occasion only, drop vibe â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Maybe this vibe has no items, but the occasion does
        tier3_sql = f"""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND lower(occasion_tags) LIKE ?
              AND price <= ?
              AND lower(size_available) LIKE ?
              {exc}
            ORDER BY RANDOM() LIMIT 1
        """
        result = run(tier3_sql,
            [category, f"%{occasion.lower()}%",
             budget_max, f"%{size.lower()}%"] + exclude_ids)
        if result:
            return result

        # â”€â”€ TIER 4: last resort â€” category + price only â”€â”€â”€â”€â”€â”€â”€
        # Guarantees we ALWAYS return something as long as any item exists
        # in this category within the budget. ORDER BY RANDOM() gives variety.
        tier4_sql = f"""
            SELECT * FROM current_inventory
            WHERE category = ?
              AND price <= ?
              {exc}
            ORDER BY RANDOM() LIMIT 1
        """
        result = run(tier4_sql, [category, budget_max] + exclude_ids)
        if result:
            return result

        # â”€â”€ TIER 4b: ignore budget too (very last resort) â”€â”€â”€â”€
        # Only reached if literally no items exist in this category
        tier4b_sql = f"""
            SELECT * FROM current_inventory
            WHERE category = ?
              {exc}
            ORDER BY RANDOM() LIMIT 1
        """
        return run(tier4b_sql, [category] + exclude_ids)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _describe_item
    # Formats one inventory item into a premium description dict
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _describe_item(self, item_dict):
        """
        Converts a raw database row into a rich, stylist-quality dict.
        This is what the GUI displays for each outfit piece.
        """
        if not item_dict:
            return None   # no item found â€” return None so GUI can skip this slot

        # Extract every field we care about from the database row
        name    = item_dict.get("item_name", "Fashion item")   # full descriptive name
        colour  = item_dict.get("colour", "")                  # e.g. "Powder Blue"
        fabric  = item_dict.get("fabric", "")                  # e.g. "Silk-Georgette"
        sil     = item_dict.get("silhouette", "")              # e.g. "A-Line"
        cut     = item_dict.get("cut", "")                     # e.g. "Anarkali"
        fit     = item_dict.get("fit", "")                     # e.g. "Regular"
        price   = item_dict.get("price", 0)                    # numeric price from DB
        brand   = item_dict.get("brand_tier", "Mid-range")     # e.g. "Premium"

        # Return a clean dict the GUI can directly read
        return {
            "name":         name,                    # full item description
            "colour":       colour,                  # colour name
            "fabric":       fabric,                  # fabric type
            "silhouette":   sil,                     # shape / silhouette
            "cut":          cut,                     # cut style
            "fit":          fit,                     # fit type
            "price":        f"â‚¹{price:,.0f}",        # formatted e.g. "â‚¹1,200"
            "brand_tier":   brand,                   # brand quality level
            "item_id":      item_dict.get("item_id", 0),  # database ID
        }

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _write_why_this_works
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _write_why_this_works(self, top, bottom_or_dress, outerwear, palette, occasion, vibe):
        """
        Creates a human-sounding, 3-sentence explanation of why
        this colour combination and outfit works for this occasion.
        """
        # Use whichever is the main piece â€” top if present, otherwise dress
        main_piece  = top if top else bottom_or_dress
        main_colour = main_piece.get("colour", "this hue") if main_piece else "this hue"

        explanation = (
            f"The {palette.get('harmony_type', 'colour')} palette anchors the look in "
            f"{palette.get('primary_colour', main_colour)}, "
            f"with {palette.get('secondary_colour', 'complementary tones')} as the natural counterpart â€” "
            f"a pairing that creates visual interest without sacrificing elegance. "
            f"For a {occasion.replace('_', ' ').title()} occasion, the {vibe} aesthetic balances "
            f"cultural context with individual expression â€” you will feel like yourself, "
            f"only at your most elevated. "
            f"The fabric and silhouette choices ensure comfort across the duration of the event "
            f"without ever compromising on visual impact."
        )
        return explanation

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPER: _write_occasion_notes
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _write_occasion_notes(self, occasion, vibe):
        """
        Returns 2 actionable, occasion-specific styling tips as a list.
        """
        notes_library = {
            "wedding": [
                "Pin your dupatta to your shoulder for maximum movement during dance sequences.",
                "Carry a small potli bag â€” a large tote reads too casual at a wedding.",
            ],
            "sangeet": [
                "Opt for footwear with a block heel or kitten heel â€” you will be dancing for hours.",
                "Layer jewellery from lightweight to statement for progression through the evening.",
            ],
            "office": [
                "Tuck your blouse in precisely â€” a clean tuck signals intentionality and confidence.",
                "Keep accessories monochromatic so attention stays on your work, not the style clash.",
            ],
            "date_night": [
                "Let one element be the statement â€” either the outfit OR the jewellery, never both.",
                "Spritz fragrance at the wrist pulse points and the back of the neck.",
            ],
            "festival": [
                "Choose breathable fabrics â€” cotton, chanderi, or georgette â€” for outdoor settings.",
                "Secure all jewellery properly before exploring crowded fair grounds.",
            ],
            "mehendi": [
                "Avoid fitted sleeves â€” you will need easy access for your hands during the application.",
                "Choose green-yellow tones to complement henna beautifully in photographs.",
            ],
        }
        # Return notes for the specific occasion, or generic notes if not in library
        return notes_library.get(
            occasion.lower(),
            [
                f"Dress one level above what you think is required â€” you will never regret it.",
                "Carry safety pins, body tape, and a small fragrance â€” a prepared outfit is a confident outfit.",
            ]
        )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # METHOD: _build_one_outfit (UPGRADED with budget distribution)
    # Builds a single complete outfit from inventory
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _build_one_outfit(self, cursor, palette, persona, occasion, vibe,
                          total_budget, size, outfit_number):
        """
        Queries inventory to fill all outfit slots for one palette.
        Uses distribute_budget to allocate spending per piece.
        Returns a complete outfit dictionary.

        total_budget: the full budget for the entire outfit (Upgrade 2)
        """
        chosen_ids = []   # track chosen item IDs to avoid duplicate pieces

        # Extract colour names from the palette for database colour matching
        primary_col   = palette.get("primary_colour", "")    # e.g. "Terracotta"
        secondary_col = palette.get("secondary_colour", "")  # e.g. "Cobalt Blue"

        # â”€â”€ UPGRADE 2: Distribute the total budget across pieces â”€â”€
        # Instead of giving every piece the same max budget, we split
        # the total proportionally based on occasion importance
        budgets = self.distribute_budget(total_budget, occasion, vibe)
        top_budget      = budgets["top_or_dress"]   # e.g. â‚¹2000 of a â‚¹5000 total
        bottom_budget   = budgets["bottom"]          # e.g. â‚¹1000
        outerwear_budget = budgets["outerwear"]      # e.g. â‚¹500
        footwear_budget = budgets["footwear"]        # e.g. â‚¹750
        bag_budget      = budgets["bag"]             # e.g. â‚¹500

        # â”€â”€ Slot 1: Try Dress first, then Top â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # full-body Dress uses the top_or_dress budget allocation
        dress = self._find_item(cursor, "Dress", vibe, occasion,
                                top_budget, size, primary_col, chosen_ids)
        if dress:
            chosen_ids.append(dress["item_id"])   # mark as taken
            top    = None   # if we have a dress, skip the top
            bottom = None   # if we have a dress, skip the bottom
        else:
            # No dress found at this budget â€” try a separate top
            top = self._find_item(cursor, "Top", vibe, occasion,
                                  top_budget, size, primary_col, chosen_ids)
            if top:
                chosen_ids.append(top["item_id"])

            # Find a bottom to pair with the top, using secondary colour
            bottom = self._find_item(cursor, "Bottom", vibe, occasion,
                                     bottom_budget, size, secondary_col, chosen_ids)
            if bottom:
                chosen_ids.append(bottom["item_id"])

        # â”€â”€ Slot 2: Outerwear (dupatta / blazer / shrug) â”€â”€â”€â”€â”€â”€â”€â”€â”€
        outerwear = self._find_item(cursor, "Outerwear", vibe, occasion,
                                    outerwear_budget, size, None, chosen_ids)
        if outerwear:
            chosen_ids.append(outerwear["item_id"])

        # â”€â”€ Slot 3: Footwear â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Footwear uses "All Sizes" because shoes use numeric sizes, not XS/M/L
        footwear = self._find_item(cursor, "Footwear", vibe, occasion,
                                   footwear_budget, "All Sizes", None, chosen_ids)
        if footwear:
            chosen_ids.append(footwear["item_id"])

        # â”€â”€ Slot 4: Bag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Bags use "One Size" since they have no size variations
        bag = self._find_item(cursor, "Bag", vibe, occasion,
                              bag_budget, "One Size", None, chosen_ids)
        if bag:
            chosen_ids.append(bag["item_id"])

        # â”€â”€ Track raw prices for budget validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # We store raw float prices from the DB rows (before formatting)
        raw_prices = {
            "dress":     (dress     or {}).get("price", 0),   # 0 if slot is empty
            "top":       (top       or {}).get("price", 0),
            "bottom":    (bottom    or {}).get("price", 0),
            "outerwear": (outerwear or {}).get("price", 0),
            "footwear":  (footwear  or {}).get("price", 0),
            "bag":       (bag       or {}).get("price", 0),
        }

        # â”€â”€ Validate that total cost fits within total budget â”€â”€â”€â”€â”€
        is_valid, total_cost, remaining = self.validate_outfit_budget(raw_prices, total_budget)
        # Note: we always proceed even if slightly over budget;
        # the validate method prints a warning and the GUI shows the overage

        # â”€â”€ Write stylist narrative â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        why_this_works = self._write_why_this_works(
            top or dress, bottom, outerwear, palette, occasion, vibe
        )
        occasion_notes = self._write_occasion_notes(occasion, vibe)

        # â”€â”€ Assemble the complete outfit dict â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        outfit = {
            "outfit_number":   outfit_number,
            # Palette name e.g. "Option A â€” Analogous Palette"
            "palette_name":    f"Option {['A', 'B', 'C'][outfit_number - 1]} â€” "
                               f"{palette.get('harmony_type', 'Curated')} Palette",
            # Three colour swatches for the UI to display as coloured circles
            "colour_swatches": [
                {"name": palette.get("primary_colour",   "Primary"),
                 "hex":  palette.get("primary_hex",   "#000")},
                {"name": palette.get("secondary_colour", "Secondary"),
                 "hex":  palette.get("secondary_hex", "#888")},
                {"name": palette.get("accent_colour",    "Accent"),
                 "hex":  palette.get("accent_hex",    "#FFF")},
            ],
            # All clothing items with their formatted details
            "items": {
                "dress":     self._describe_item(dress)      if dress     else None,
                "top":       self._describe_item(top)        if top       else None,
                "bottom":    self._describe_item(bottom)     if bottom    else None,
                "outerwear": self._describe_item(outerwear)  if outerwear else None,
                "footwear":  self._describe_item(footwear)   if footwear  else None,
                "bag":       self._describe_item(bag)        if bag       else None,
            },
            # Budget information (Upgrade 2 additions)
            "total_cost":           total_cost,            # raw float, e.g. 2840.0
            "total_estimated_cost": f"â‚¹{total_cost:,.0f}", # formatted, e.g. "â‚¹2,840"
            "budget_given":         total_budget,          # the user's stated budget
            "budget_remaining":     max(0, remaining),     # money left over (0 if over)
            "within_budget":        is_valid,              # True if fits, False if over
            # Stylist narrative
            "why_this_works":       why_this_works,
            "occasion_notes":       occasion_notes,
            "colour_rationale":     palette.get("colour_rationale", ""),
        }

        return outfit   # return the complete outfit dict

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # METHOD: run â€” THE MAIN ENTRY POINT (UPGRADED)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def run(self, palettes, persona, occasion, vibe, total_budget=None):
        """
        Builds 3 complete outfits â€” one per colour palette.
        Now uses total_budget for full-outfit budget distribution (Upgrade 2).
        After each outfit, calls LiveLinkScraper to add shopping links (Upgrade 1).

        palettes:     list of 3 palette dicts from ColourEngineAgent
        persona:      dict from PersonaAgent with size, etc.
        occasion:     e.g. 'wedding', 'office', 'date_night'
        vibe:         e.g. 'Ethnic', 'Modern', 'Boho'
        total_budget: the user's TOTAL budget for the complete outfit (Upgrade 2)
                      Falls back to persona budget_max if not provided.

        Returns: list of 3 outfit dicts (each enriched with shopping links)
        """
        print(f"  ğŸ‘— Wardrobe Architect: Building 3 looks for {occasion} ({vibe} vibe)...")

        # Resolve total budget: prefer the directly passed value,
        # fall back to persona's budget_max for backwards compatibility
        if total_budget is None:
            total_budget = persona.get("budget_max", 15000)   # fallback to persona budget

        # Get the user's clothing size from persona profile
        size = persona.get("size", "M")   # default to Medium if not set

        print(f"  ğŸ’° Total outfit budget: â‚¹{total_budget:,.0f} | Size: {size}")

        # Open the database connection for all queries
        conn   = self._get_db_connection()
        cursor = conn.cursor()

        outfits = []   # list to collect all 3 completed outfits

        # â”€â”€ Create live link scraper instance (Upgrade 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # We create ONE scraper and reuse it for all outfits
        scraper = LiveLinkScraper() if LINKS_AVAILABLE else None

        # â”€â”€ Loop through each colour palette and build one outfit â”€â”€
        for outfit_number, palette in enumerate(palettes, start=1):
            print(f"\n  Building Outfit {outfit_number} ({palette.get('harmony_type', '')})...")

            outfit = self._build_one_outfit(
                cursor    = cursor,
                palette   = palette,
                persona   = persona,
                occasion  = occasion,
                vibe      = vibe,
                total_budget = total_budget,   # pass the full budget (Upgrade 2)
                size      = size,
                outfit_number = outfit_number
            )

            # â”€â”€ Add shopping links to every item (Upgrade 1) â”€â”€â”€â”€â”€â”€â”€
            if scraper is not None:
                print(f"  ğŸ›  Finding shopping links for Outfit {outfit_number}...")
                try:
                    outfit = scraper.get_outfit_links(outfit)   # enrich with real URLs
                except Exception as link_error:
                    # Never let link scraping crash the outfit generation
                    print(f"  âš ï¸  Link scraping failed for outfit {outfit_number}: {link_error}")

            outfits.append(outfit)  # add completed outfit to our list
            print(f"  âœ…  Outfit {outfit_number} ready "
                  f"(â‚¹{outfit['total_cost']:,.0f} of â‚¹{total_budget:,.0f})")

        conn.close()   # close the database connection when all outfits are built
        print(f"  âœ… All 3 outfits ready!")
        return outfits   # return the list of 3 enriched outfit dicts
